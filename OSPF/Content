- OSPF ( Open Shortest Path First )
- 내부 게이트웨이 라우팅 프로토콜 
- Link State Routing Protocol 
-- 각 라우터는 자신과 자신의 인터페이스를 직접 연결된 이웃 라우터에게 설명을 한다.
-- 각 라우터는 모든 라우터와 인터페이스 및 연결 상태를 비롯한 네트워크 전체의 상황을 학습한다.
-- 링크 상태 통보를 통해 라우팅 업데이트를 전달
- Multicast로 메세지를 전송
- 개방형 표준 프로토콜 ( Open Standard Protocol )
- Dijkstra 최단 경로 우선 알고리즘을 사용하여 학습된 네트워크로 통하는 최적의 경로를 산출

- OSPF가 활성화하면 가장 먼적 하는 일은 직접 연결된 이웃 라우터를 파악해 연결 관계를 형성하는 작업 
- LSDB ( Flood Link Sㅁtate Database ) 링크 상태 데이터베이스 정보를 보내, 경로를 공유
- 모든 잠재적 경로를 학습하고 나면 라우터는 최단 경로를 산출하고 라우팅 표에 최적의 경로를 입력 
- 라우터들이 네트워크의 변화, 예를 들어 새 링크가 끊어졌거나 추가되었거나 하는 네트워크 변경 사항에 반응을 한다.

- OSPF Packet Types
- Hello Packet 
-- 인터페이스에서 OSPF를 활성화한 직후에 OSPF는 Hello Packet을 보내고, 수신 대기를 한다.
-- 해당 인터페이스에서 Hello Packet를 수신하면 이웃 라우터와 인접성을 형성
- DBD ( DataBase Description )
-- 데이터베이스의 서술 , 라우터에서 네트워크에 대해 알고 있는 모든 정보가 포홤되어 있다.
-- 인접성이 형성된 라우터들 사이
-- 만약 라우터가 이웃 라우터로부터 수신한 DBD 내에 특정 네트워크에 대한 정보가 누락된 경우에는 
-- 이웃 라우터에 LSR을 보내 정보를 요청한다.
- LSR ( Link State Request )
-- 그럼 해당 라우터는 링크 상태 알림인 LSA ( Link State Advertisement ) 보내 회신을 한다.
-- 다른 패킷으로는 LSU ( Link State Update ) 링크 상태 업데이트가 있는데, 업데이트가 필요한 LSA의 목록을 
-- 포함하며 플러딩 과정에서 사용이 된다.
-- 예를 들어, 새 링크가 추가되었거나 특정 링크가 먹통이 되면 해당 정보는 LSU가 내에 모든 곳으로 전송이 되어야 한다.
-- LSAck 수취 확인 메세지 ( Routers Acknowledge LSAs )
-- 라우터들이 이웃 라우터에게서 메세지를 수신할 때 라우터는 수취 확인을 회신, 프로토콜의 신뢰도를 확실하게 하기 위해
-- 만약 한 라우터가 패킷을 보냈는데 수취 확인을 받지 못하면 패킷을 재전송한다.

구분	                거리 벡터	                링크 스테이트
정보 교환 범위	     인접 라우터와 정보 교환	    네트워크 전체 맵 공유
경로 계산 방식	        거리와 방향 기반	      다익스트라 알고리즘 사용
네트워크 반응 속도	        느림	                    빠름
구현 복잡도 및 리소스	  간단, 적음	              복잡, 많음
예시 프로토콜	            RIP	                       OSPF

- vs RIP vs EIGRP
-- RIP
-- 확장성이 한정되어 있다.
-- 소규모의 프로덕션 네트워크나 랩 또는 테스트 환경에 적합

-- OSPF
-- 따라서 프로덕션 네트워크에서는 IGP ( 내부 게이트웨이 라우팅 프로토콜 ) 선택지에는 EIGRP or OSPF로 좁혀진다.
-- 둘 중에서는 OSPF가 널리 활용된다.
-- 대형 네트워크를 지원하고 개방형 표준으로 사용되어 왔다 -> 모든 제조업체 장치들에 지원이 된다

-- EIGRP
-- 구현 및 문제 해결이 더 간단하다
-- 역사적으로 Cisco 전용 프로토콜이었다 -> 현재는 개방형 표준이지만 다른 제조업체 장치들에 대한 지원은 매우 한정적이다.

- RIP ( Routing Information Protocol ) 수립 과정
- RIP는 거리 벡터 기반으로 라우팅 정보를 설정합니다.
- 초기화
-- 각 라우터는 자신만의 라우팅 테이블을 가지고 시작합니다.
-- 테이블에는 자신과 직접 연결된 네트워크 정보만 포함됩니다.
- 라우팅 정보 교환
-- 일정 간격(기본적으로 30초)마다 인접 라우터와 라우팅 테이블을 주고받습니다. 
- 테이블 업데이트
-- 받은 정보를 바탕으로 경로를 갱신합니다.
-- 각 네트워크까지의 홉 수(거리)를 계산하여 최단 경로를 유지합니다.
-- 최대 홉 수는 15로 제한되며, 16 이상은 도달 불가로 간주됩니다.
- 안정화
-- 모든 라우터가 서로의 정보를 주고받고, 최적의 경로를 설정하면 수립 과정이 완료됩니다.

- OSPF (Open Shortest Path First) 수립 과정
- OSPF는 링크 상태 기반으로 네트워크 전체 정보를 사용해 최단 경로를 설정합니다.
- Hello 패킷 교환
-- 각 라우터는 Hello 패킷을 인접 라우터로 전송하여 이웃 관계를 형성합니다.
-- 이웃 라우터 간 인증 및 연결이 설정됩니다.
- 링크 상태 광고 (LSA) 전송
-- 라우터는 자신과 연결된 링크(네트워크 상태) 정보를 담은 LSA ( Link State Advertisement )를 생성하여 
-- 네트워크 전체에 전파합니다.
- 링크 상태 데이터베이스 (LSDB) 생성
-- 모든 라우터는 받은 LSA 정보를 기반으로 LSDB를 구축합니다.
-- 네트워크 전체의 연결 상태를 파악할 수 있는 구조입니다.
- 다익스트라 알고리즘 실행
-- LSDB를 바탕으로 다익스트라 알고리즘을 실행하여 최단 경로 트리를 계산합니다.
-- 이를 통해 최적의 경로가 라우팅 테이블에 설정됩니다.
- 안정화
-- 네트워크 상태에 변화가 발생하면 다시 LSA를 전송하고, LSDB와 라우팅 테이블을 갱신하여 수립 과정을 반복합니다.

- Global Config mode
- router ospf 1 ( 프로세스 ID )
- 라우터의 서로 다른 인터페이스는 OSPF의 서로 다른 인스턴스나 프로세스 ID에서 실행될 수 있다.
- 서로 다른 인스턴스는 서로 다른 링크 상태 데이터베이스를 가지므로 별도로 실행된다.
- 일반적으로 OSPF 라우터에서는 하나의 인스턴스만 구성

- EX)
- ID : 프로세스 ID , [] : router
- ID 1 [R3] ID 1 ----- ID 3 [R2] ID 2 ----- ID 4 [R1]

- 라우터에서 프로세스 ID가 다르더라도 이는 로컬에서만 중요한 숫자다. 
- 양쪽에서 일치할 필요가 없으므로 라우터는 여전히 인접성을 형성할 것이다.
- 예시에서 R2의 왼쪽 및 오른쪽 인터페이스는 두 개의 다른 인터페이스가 있다.
- 따라서 별도의 링크 상태 데이터베이스를 가지게 되며 양자 간에 정보가 공유되지 않을 것이다.
- 따라서 R1과 R3는 서로의 경로를 학습하지 못할 것이다.

- network   10.0.0.0      0.0.255.255    area 0
- 네트워크  네트워크 주소  와일드 카드 마스크   영역

- network 10.0.0.0
- 와일드 카드 마스크 생략 시 클래스풀 와일드카드 마스크를 기본값으로 설정되지 않는다. -> 입력해야 한다.
- 해당 범위에 속하는 IP 주소를 가진 인터페이스를 찾아서 해당 인터페이스에 OSPF를 활성화한다.
- OSPF Hello 메세지를 보내고 수신하며 인접한 OSPF 라우터와 피어링한다.
- 인접성이 형성되면 해당 인터페이스에 구성된 네트워크와 마스크를 광고한다.

- show running-config | section ospf
- OSPF 설정 확인 

- show ip protocols
- 라우터에서 실행 중인 모든 라우팅 프로토콜 확인

- show ip ospf interface brief
- 라우터에서 어떤 인터페이스에 OSPF가 활성화되었는지 확인

- show ip ospf neighbor
- 라우터가 서로를 볼 수 있고 인접성이 형성되었는지 확인

- show ip ospf database
- 경로가 학습되었는지 확인 
- 해당 영역과 OSPF 네트워크 전체에서 사용 가능한 모든 링크 확인

- show ip route
- 라우팅 테이블에 OSPF 경로가 있는지 확인

- Router ID
- 기본적으로 라우터에 구성된 루프백 인터페이스 중 가장 높은 IP 주소를 사용
- 루프백 인터페이스가 없을 경우 가장 높은 다른 IP 주소를 사용
- 루프백을 사용하거나 수동으로 설정
- 기존에 루프백 인터페이스가 없이 라우터 ID가 설정되었는데 추후 루프백 인퍼페이스를 구성해도 라우터 ID는 바뀌지 않는다
- 라우터를 재부팅하거나 OSPF 프로세스를 재시작해야 바뀐다.

- 수동 설정
- router ospf 1
- router-id [ IP ] Ex) 2.2.2.2
- 사용하려는 주소는 실제로 라우터에 구성되어 있을 필요가 없다.
- 그러나 실제로 라우터에 구성된 IP주소를 사용하는 것이 논리적이며 문제 해결이 더 쉽다.

- Passive Interface Configuration ( 수동 인터페이스 설정 )
- router ospf 1
- passive-interface loopback 0
- passive-interface f2/0
- 수동 인터페이스를 구성하면 OSPF에서 광고가 ( Advertisement ) 된다.
- 다른 라우터는 해당 인터페이스에 도달하는 방법을 배우지만 인터페이스 자체는 인접성을 형성하려고 하지 않으며   - 내부 정보를 제공하지 않는다 

- 수동 
- passive-interface default -> 모든 인터페이스를 수동

- no passsive-interface f0/0 ->
- no passsive-interface f1/0 -> 라우터가 해당 링크에서 인접성을 형성하도록 설정
- no passsive-interface f2/0 ->

- 기본 경로 주입 ( Default Route Injection )
- Internet ( 203.0.113.2 ) <-> ( 203.0.113.1 ) FE3/0 [R4] <-> [R3] <-> [R2] <-> [R1]
- EX) R4가 인터넷 서비스 제공자에 연결된 경우 
- R4) ip route 0.0.0.0 0.0.0.0 203.0.113.2
- R4) router ospf 1
- R4) default-information originate
- 모든 라우터에 인터넷으로 나가는 정적 경로를 구성하고 싶지는 않고 동적으로 학습하도록 하고 싶을 때
- R4 라우터의 OSPF 프로세스에 이를 주입
- 라우터에서 기본 경로를 찾고 그것을 OSPF에 주입

- External Route
- 외부 프로토콜의 경로 정보를 OSPF에 주입하는 것
- OSPF 내부 네트워크가 외부 네트워크(예: 인터넷, 다른 라우팅 프로토콜 사용 네트워크)와 통신할 수 있도록 경로 
- 정보를 공유

- 주입 과정 요약
- 외부 프로토콜 경로 학습
- OSPF 라우터가 외부 라우팅 프로토콜(예: BGP, RIP, 정적 경로 등)로부터 경로 정보를 가져옵니다.

- 재분배 ( Redistribution )
- 외부 프로토콜의 경로 정보를 OSPF 내부 라우팅 도메인에 주입합니다.
- 이를 통해 OSPF가 외부 네트워크 경로를 알게 됩니다.

- External LSA 생성
- OSPF는 외부 경로 정보를 Type 5 LSA ( External LSA )로 만들어 OSPF 도메인에 전파합니다.
- External Route로 라우팅 테이블 업데이트
- OSPF는 주입된 외부 경로를 E1 또는 E2 타입의 External Route로 라우팅 테이블에 추가합니다.

- E1 Type
- 외부 경로의 비용에 더해 내부 네트워크에서의 전송 비용도 누적하여 계산 → 경로의 전체 비용을 고려.

- E2 Type
- 외부 경로의 비용은 고정된 값으로 유지. 내부 비용은 무시 → 단순히 외부 경로를 최우선으로 사용.

- Ex) 인터넷 연결
- 회사 내부 네트워크는 OSPF를 사용하고, 인터넷은 BGP로 연결되어 있다고 가정합니다.
- OSPF 라우터가 BGP 라우팅 정보를 가져와 OSPF 도메인에 External Route로 주입하면, 내부 네트워크의 모든 OSPF - 라우터가 인터넷 경로를 학습할 수 있습니다.

- 루프백 인터페이스 설정 후 OSPF 재시작
- interface loopback 0
- ip address 1.1.1.1 255.255.255.255
- no router ospf 1
- router ospf 1
- network 10.0.0.0 0.255.255.255 area 0

- 라우터 ID 수동 설정 후 OSPF Reload
- router-id 2.2.2.2
- clear ip ospf process

- 인터넷으로 향하는 경로를 다른 내부 라우터들이 학습하게
- passive-interface fastEthernet 3/0
- network 203.0.113.0 0.0.0.255 area 0 -> 경로가 내부로 통보될 수 있도록


- network 203.0.113.0 0.0.0.255 area 0
- 외부 네트워크 경로 자체를 학습하도록 만드는 설정
- OSPF 내부 라우터들이 203.0.113.0/24 네트워크로 어떻게 가야 할지를 알게 된다.
- 이 설정이 없으면, 내부 라우터는 ASBR( 203.0.113.1 )로 트래픽을 보내는 방법 자체를 알지 못한다.
- ASBR( 203.0.113.1 )로 가는 길은 이렇게 간다. ( 목적지인 문지기까지의 경로 )

- 기본 경로 주입
- ip route 0.0.0.0 0.0.0.0 203.0.113.2
- router ospf 1
- default-information originate
- 내부 라우터들에게 모든 미지정 트래픽(인터넷으로 나가는 트래픽)은 ASBR로 보내라 라는 기본 경로(0.0.0.0/0)
- 정보를 전달하는 설정입니다.
- OSPF 내부 라우터들은 인터넷으로 나가려면 ASBR( 203.0.113.1 )을 통해야 한다고 학습합니다.
- 인터넷으로 나가려면 문지기(ASBR)를 통해 나가면 된다. ( 외부 세계로 나가는 방향 )


- Area
- 모든 라우터는 네트워크 자신의 부분에 대한 전체 그림을 학습하며 여기에는 모든 라우터, 그 인터페이스 및 연결된 - 것이 포함 -> 대규모 네트워크에서 문제를 일으킬 수 있다.
- 모든 라우터가 모든 링크에 대해 알고 있기 때문에 라우팅 테이블에 많은 경로가 존재하게 되고 과도한 메모리를 
- 차지할 수 있다
- 또한 네트워크에 새로운 링크가 추가되거나 링크가 다운되는 등의 변화가 있을 경우 모든 라우터가 재수렴하므로
- 이는 시간과 CPU 자원을 소모한다.
- 이를 완화하기 위해 OSPF는 대규모 네트워크를 더 작은 영역으로 분할하는 계층적 설계를 지원
- 각 라우터는 자신의 영역에 대한 전체 정보를 유지하지만 다른 영역에 대해서는 요약 정보만 유지
- 따라서 다른 영역에서 새로운 링크가 생기거나 사라져도 해당 라우터에는 영향을 미치지 않는다.

- 2단계 계층 구조
- 최상위 수준에서는 전송 영역 ( Transit area - backbone or area 0 )
- 다중 영역 네트워크에서는 일반적으로 최종 사용자를 포함하지 않는다.
- area 0 아래에 매달려 있는 일반 영역 ( Regular areas - nonbackbone )
- 최종 사용자를 전송 영역에 연결하는데 사용
- 기본 적으로 모든 전송 트래픽은 전송 영역을 통해 이동한다.
- EX)
-            Area 0
           |        |
-    Area 1          Area 2
- Area 0가 있고 Area1,2가 그 아래 매달려 있다.
- Area 0이 아닌 다른 영역 간의 모든 트패릭은 항상 Area 0을 통해 이동해야 한다.
- Area 1과 Area 2 사이에 직접 트래픽이 갈 수 없다.

- 단일 영역 설계를 할 때는 Area 0가 될 것이다

- network 10.0.0.0 0.0.255.255 area 0
- 이 라우터의 IP 주소가 해당 범위에 속하는 모든 인터페이스는 OSPF로 활성화되고 Area 0에 배치된다.
- 라우터가 인접성을 형성하려면 링크 반대편의 이웃이 동일한 영역으로 구성되어 있어야 한다.
- 영역 불일치가 있으면 인접성이 형성되지 않고 라우터들은 서로 경로를 공유하지 않는다.
- 동일한 영역에서 수신된 경로 -> Internal 영역 경로

- ABR
- 영역 경계 라우터
- 인터페이스와 여러 영역을 가진 라우터 
- 위의 예시에서는 Area 0와 Area 1 각각의 인터페이스가 있는 라우터 , Area 0와 Area 2 각각의 인터페이스가 있는 - 라우터
- 플러딩 영역을 분리
- 네트워크를 다른 영역으로 분리하고 네트워크를 구획하 하는 것 
- 해당 영역에서 링크가 올라가거나 내려가면 정보는 그 한 영역에서만 유지 -> 다른 영역에서는 영향을 미치지 않는다.
- OSPF에서 요약을 항상 수행하는 곳 -> OSPF에서 요약은 항상 ABR에서 수행
- 다른 일반 영역의 기본 경로의 소스로 정기적으로 작동하며 연결된 각 영역에 대한 링크 상태 데이터베이스 ( LSDB )
- 를 유지
- ABR은 자동으로 요약하지 않는다 -> 수동으로 이를 수행해야 하며 수동으로 설정하지 않으면 
- 모든 경로가 모든 곳에 플러딩되어 네트워크가 기본적으로 하나의 큰 영역처럼 작동하게 된다.
- 즉, 여러 영역을 구성하는 목적은 더 큰 네트워크에서 자원을 덜 사용하고 라우터에 부담을 덜어 주기 위함이다.
- 따라서 단순히 다른 영역을 구성하는 것만으로는 충분하지 않으며 ABR에서 요약( summarisation )을 구성해야만 
- 실제로 그로부터 이점을 얻을 수 있다.

- EX)
- Area 0       ABR          Area 1
-          [R1] <-----> [R2] <-----> [R3] <-----> [R4]
- 10.1.1.1      10.1.0.0     10.0.0.0      10.0.1.1

- router ospf 1
- network 10.1.0.0 0.0.255.255 area 0
- network 10.0.0.0 0.0.255.255 area 1
- area 0 range 10.1.0.0 255.255.0.0
- area 1 range 10.0.0.0 255.255.0.0

- Area 0 [R1] -> 10.0.0.0/24, 10.0.1.0/24 경로를 가지는 대신 단일 요약 경로인 10.0.0.0/16를 가지게 된다.
- [R1] 에는 더 적은 경로가 있어 라우터의 자원을 덜 차지하게 된다.
- 다른 영역에서 장애가 발생하더라도 이 영역에 있는 라우터에는 영향을 미치지 않는다.

- show ip route
- O IA ( Inter Area ) -> 인터 영역 경로인 다른 영역에 있는 ABR에서 학습한 경로 표시

- ASBR ( Autonomous System Boundary Router ) , 자율 시스템 경계 라우터
- 그 라우터에서 OSPF를 실행하고 있으며 다른 소스에서 OSPF로 재배포하고 있다는 것
- 그 라우터에서 EIGRP, RIP도 실행하고 있으며 EIGRP나 RIP 경로를 가져와서 OSPF로 재배포하고 있으며
- 그것들은 OSPF 이웃을 통해 광고될 것이다.
- 또는 그것이 OSPF로 재배포되는 정적 경로일 수도 있다.
- 라우터에서 OSPF로 재배포하고 있다는 것을 의미

- O*E1 or O*E2


- O -> 인트라 영역 경로 , 목적지가 같은 경로
- O IA -> 다른 영역에서 ABR에 의해 학습된 영역 간 경로
- O*E1 or O*E2 -> OSPF로 재배포되었다

- 비용 메트릭
- 대역폭 vs 클럭 비율과 속도 ( Bandwidth VS Clock Rate and Speed ) 

- speed 
- 이더넷 인터페이스의 물리적 전송 속도는 speed 명령어로 지정된다.
- GigabitEthernet 인터페이스는 기본으로 초당 1,000Mbit( 1Gbps )를 전송
- fastEthernet 인터페이스는 기본으로 초당 100Mbps를 전송
- speed 설정 시 링크 양쪽에 수동으로 설정해야 하고 speed가 동일하지 않으면 문제 발생

- clock Rate
- 직렬 인터페이스( Serail interface )에서 작동하는 명령어
- 직렵 인터페이스는 WAN 링크에서 흔히 사용이 되었었고 지금은 자주 쓰지이 않는다.
- 직렬 인터페이스의 물리적 전송 속도는 clock rate 명령어로 지정
- 기본 속도는 1.544Mbps
- clock rate 64000 -> 물리적 전송 속도는 64kbps
- clock rate 명령어를 사용해 kbps로 변경할 수 있다.
- clock Rate 설정 시 링크 양쪽에 수동으로 설정해야 하고 clock rate가 동일하지 않으면 문제 발생

- Bandwidth
- 인터페이스는 기본 대역폭을 가지고 있다.
- 일반적으로 인터페이스의 물리적 전송 속도와 동일
- fastEthernet -> 100Mbps
- Serail Interface -> 1.544Mbps
- 인터페이스에 설정된 대역폭은 물리적 전송 속도에는 영향을 미치지 않는다.
- fastEthernet 인터페이스에 Bandwidth를 50Mbps로 설정해도 전송 속도는 여전히 100Mbps다
- 대역폭 설정은 라우터의 소프트웨어 정책에 영향을 준다.
- EIGRP or OSPF와 같은 라우팅 프로토콜로 어떤 경로가 선댁될지, 혹은 QoS에 의해 얼마만큼의 대역폭이 보장될지

- OSPF 메트릭
- 라우터는 해당 영역 내의 모든 목적지로 가는 링크 및 그 비용에 대해 학습
- 라우터는 목적지에 도달하는데 드는 가장 낮은 비용을 기준으로 경로를 선택하며 그 경로가 라우팅 테이블에 포함

- 다중 영역 OSPF 네트워크에서는 ABR이 연결된 각 영역의 정보를 알고 있으며
- 각 라우터는 자신의 영역 내의 각 IP 서브넷에 대한 개별 경로와
- ABR을 통해 가는 다른 영역에 대한 요약 경로를 가지고 있다.
- 자신의 영역 내의 목적지에 대해서는 라우터가 사용할 수 있는 모든 링크를 검토하고 전체 비용이 가장 낮은 경로 선택
- 다른 영역의 목적지에 대해서는 라우터가 ABR에 도달하기 위한 모든 가능한 링크를 검토하고
- ABR까지의 전체 비용이 가장 낮은 경로를 선택하고 ABR이 그곳에서 최적의 경로를 선택

- SPF ( Shortest Path First Algorithm ) 최단 경로 우선 알고리즘은 각 목적지 네트워크로 가는 모든 가능한
- 경로의 전체 비용을 계산하고 가장 낮은 비용의 경로를 선택
- 전체 비용은 모든 출력 인터페이스의 누적 비용
- OSPF가 여러 경로가 있을 때 단지 목적지에 도달하기 위해 사용할 수 있는 모든 다른 출력 인터페이스의 비용을 살펴보고
- 누적 비용이 가장 낮은 경로가 선호되는 경로가 된다.
- 링크 양쪽의 인터페이스에 동일한 비용이 설정되었는지 확인해야 한다. -> 비대칭 라우팅 발생
- 링크의 양쪽에 다른 비용이 있다면 트래픽이 서로 다른 방향으로 다른 경로를 택할 수 있다.

- 참조 대역폭 ( Reference Bandwidth )
- 더 높은 대역폭의 인터페이스가 자동으로 선호
- 비용이 계산되는 방식은 참조 대역폭을 실제 인터페이스 대역폭으로 나누는 것
- 기본 참조 대역폭은 100Mbps 
- fastEthernet -> 비용은 1 ( 100 / 100 )
- Serail Interface -> 비용은 64 ( 100 / 1.544 )

- OSPF에서는 100Mbps 초과의 모든 인터페이스를 동일하게 취급하기 떄문에 가능한 최상의 비용은 1이다
- 따라서 고속 이더넷, 기가비트 이더넷, 10기가비트 이더넷 등은 모두 기본적으로 비용이 1로 설정되며
- 현대의 고속 이더넷 인터페이스를 사용하는 네트워크에서 바람직하지 않는 라우팅을 초래한다.
- 이를 강제할 수 있는 방법은 참조 대역폭을 변경하는 것이다
- router ospf 1
- auto-cost reference-bandwidth 100000
- 모든 라우터에 적용해서 일관성을 보장하자

- bandwidth 변경 명령어
- show interface serial1/0
- BW 1544 Kbit/sec
- interface serial1/0
- bandwidth 768
- 물리적 수준에서는 링크가 여전히 클럭 속도로 작동할 것이다.
- 대역폭을 설정하는 것은 실제 물리적 속도를 변경하지 않으며 IOS가 소프트웨어 정책을 해당 인터페이스를 보는 방식을 변경
- 해당 링크의 전체 비용을 조작할 수 있는 방법

- 더 나은 방법은 직접 비용을 변경하는 것
- 이렇게 하면 QoS와 같은 다른 소프트웨어 정책에 영향을 미치지 않는다.
- interface FastEthernet 0/0
- ip ospf cost 50

- 링크 비용 확인 
- show ip ospf interface FastEthernet 0/0

- 라우터에서 OSPF를 활성화하면 먼저 OSPF 이웃을 발견
- 라우터는 이들과 인접성을 형성하고 OSPF로부터 학습한 모든 네트워크를 포함한 링크 상태 데이터베이스를 구축
- 그 다음 각 네트워크에 대한 최단 경로를 계산하고 최적의 경로를 라우팅 테이블에 기재
- 네트워크에서 링크가 다운되는 등의 변화가 발생하면 라우터는 네트워크 변경에 대응하여 라우팅 테이블을 업데이트

- Hello Packet
- OSPF가 인터페이스에서 활성화되면 라우터가 보내고 수신하는 패킷 
- 라우터에서 전역적으로 OSPF를 활성화하고 네트워크 명령문으로 인터페이스에서 OSPF를 활성화하면 
- 라우터는 Hello 패킷을 보내고 수신하기 시작하며 해당 링크에서 다른 OSPF 라우터와 인접성을 형성

- passive-interface에서는 제외 -> 내부 네트워크에 대한 정보를 외부로 전송하거나 업데이트를 공유하지 않는다
- 해당 인터페이스에 구성된 네트워크가 내부적으로 광고되어 내부 라우터가 해당 네트워크를 알 수 있게 되지만 그 링크를 통해 내부 정보를 외부로 제공하지는 않는다. 
- 루프백 인터페이스도 패시브 인터페이스 설정

- DBD ( DataBase Description )
- 인접 라우터가 서로 알고 있는 네트워크를 DBD 패킷으로 알려주는 것

- LSR ( Link State Request )
- 라우터가 이웃으로부터 받은 DBD에 있는 네트워크에 대한 정보가 부족하면 해당 이웃에게 LSR을 보내 추가 정보 요청

- LSA ( Link State Advertisement )
- 라우팅 업데이트

- LSU ( Link State Update )
- 업데이트 해야 할 LSA 목록을 포함하는 링크 상태 업데이트
- 링크가 다운되었을 때 플러딩 중에 사용

- LSAck
- OSPF로부터 정보를 포함한 패킷을 수신할 때 수신 라우터가 LSA를 확인하고 이를 보낸 라우터에게 확인 응답을 보낸다.

- OSPF Protocol
- EIGRP와 유사하게 OSPF는 자체 프로토콜 번호를 사용
- 표준 IP 패킷의 3계층 IP 헤더에는 프로토콜을 위한 필드가 있다.
- TCP : 6
- UDP : 17
- OSPF : 89

- OSPF Packet
- Version Number | Type | Packet Length | Router ID | Area ID | Checksum | Authentication Type | Authentication | Data
- Version : OSPFv2 or OSPFv3
- Type : Hello(1) , DBD(2) , LSR(3) , LSU(4) , LSAck(5) -> LSA는 자체 패킷 타입이 없으며 LSUs에 포함
- Authentication Type : No-Password(0) , Plain-text-Password(1), MD5-authentication(2)
- data : 라우팅 업데이트와 같은 데이터 페이로드



- Hello 패킷이 전송될 떄 모든 OSPF 라우터의 멀티캐스트 주소로, 지정된 멀티캐스트 주소 224.0.0.5로 멀티캐스트되며
- 기본적으로 10초마다 Hello 패킷이 전송
- 이는 인접성을 형성하고 서로 경로를 교환하는 것 이외에도 다른 라우터가 여전히 작동 중인지 확인

- Hello Packet Contents
- Router ID : 각 OSPF 라우터를 고유하게 식별하는 32bit number ( IPv4 같은 )
- Hello Interval : 라우터가 Hello 패킷을 보내는 빈도. 기본값은 10초
- Dead Interval : 라우터가 이웃으로부터 신호를 기다리는 시간, 이 시간이 지나면 서비스 중단으로 선언, 라우터가 이웃으로부터 Dead Interval 동안 Hello 패킷을 받지 못하면 그 이웃이 다운되었다고 가정. 기본값은 Hello Interval의 4배
- Heighbors : 라우터가 Hello 패킷을 받은 인접 OSPF 이웃의 목록
- Area ID : OSPF 라우터가 ABR인 경우 여러 다른 영역에 있는 인터페이스를 가질 수 있다, 그래서 영역은 링크, 즉 인터페이스 수준에서 구성된다.
- Router Priority : 지정 라우터 (DR)와 백업 지정 라우터 (BDR)를 선택하는데 사용되는 8bit number
- DR and BDR IPv4 Address : If known
- Authentication Flag : 인증이 구성된 경우에 포함 - OSPF 구성에 비밀번호를 포함 - 양쪽에 라우터가 일치하는 비밀번호를 가지자
- Stub Area Flag : 해당 영역이 Stub 영역인지, Stub 영역은 영역 외부의 경로를 학습하는 대신 ABR로의 기본 경로를 가진다.
- Stub 영역에서는 ABR을 통해 들어가고 나오는 단 하나의 경로만 존재, 이는 네트워크 전체의 모든 경로를 학습하는 대신 Stub 영역 내 라우터에 대한 부하를 줄여준다

- MTU ( Maximum Transmission Unit )
- 라우터의 링크를 통해 전송될 수 있는 패킷의 최대 크기
- 기본값 1500 bytes
- 라우터 인터페이스 설정

- interface GigabitEthernet 0/0
- mtu 1480 -> 인터페이스 MTU 설정
- ip mtu 1460 -> IP MTU 설정
- 일반적으로는 하나만 변경하는데 IP MTU를 설정한다

- show interface GigabitEthernet 0/0 -> 인터페이스 MTU 확인
- show ip interface GigabitEthernet 0/0 -> IP MTU 확인

- MTU가 다른 상황에서 라우터에 OSPF를 설정하면 
- show ip ospf neighbors 명령에서 서로를 이웃으로 인식하게 된다.
- 그러나 실제로 서로 OSPF 경로를 공유할 수는 없다.

- 라우터에 OSPF를 전역적으로 활성화한 상태 Neighbor States 
- EX) 
- 172.16.1.1/24 [R1] 10.0.0.1/30 <--------> 10.0.0.2/30 [R2] 172.16.2.1/24
-             Hello Packet ---------------------------->
-     [I am Router ID 172.16.1.1 and I have no neighbors (to 224.0.0.5)]
-   기본적으로 루프백 인터페이스가 없으므로 가장 높은 물리적 주소를 라우터 ID로 사용
-             <---------------------------- Hello Packet
-     [I am Router ID 172.16.2.1 and I see 172.16.1.1 (to 10.0.0.1)]
- 만약 지금 다른 OSPF 이웃이 있다면 이 정보에 포함시킨다. 그래서 R1에게 모든 이웃에 대해 알려주며 R1도 포함된다.
-             Hello Packet ---------------------------->
-     [I am Router ID 172.16.2.1 and I see 172.16.2.1 (to 10.0.0.2)]
-   라우터들이 이웃 목록에서 서로를 볼 수 있어야 한다는 요구 사항을 충족
-   라우터들은 양방향 상태, 그러나 아직 경로를 교환하기 시작하지는 않았다

-               DBD Packet ---------------------------->
-          [I will start Exchange with my Router Id 172.16.1.1]
-               <---------------------------- DBD Packet
-    [No I will start Exchange because I have higher Router ID 172.16.2.1]
- 누가 교환을 시작할 것인지에 대한 협상일 뿐 가장 높은 라우터 ID를 가진 쪽이 될것이다

-                         서로 라우팅 정보 교환
-               <---------------------------- DBD Packet
-                           [LSDB Summary ]
-   링크 상태 데이터베이스의 요약본으로 R1이 이미 정보를 가지고 있을 수 있기 때문에 전체 정보를 보내지 않는다. 네트워크 부하를 줄이기 위해
-   자신이 알고 있는 네트워크에 대한 요약만 보낸다.
-               LSAck Packet ---------------------------->
-                           [Acknowledged ]
-   R1은 그 패킷이 수신되었음을 확인하는 유니캐스트를 R2에게 다시 보낸다.
-               DBD Packet ---------------------------->
-                           [LSDB Summary ]
-   그 다음 R1ㄷ은 데이터베이스 설명자와 함께 자신의 LSDB 요약을 R2에 보낸다.
-               <---------------------------- LSAck Packet
-                           [Acknowledged ]
-   R2은 그 패킷이 수신되었음을 확인하는 유니캐스트를 R1에게 다시 보낸다.

-                       로딩 상태 or 로딩 단계
-               <---------------------------- LSR Packet
-                 [I need full info on 172.16.1.0/24]
-               LSU Packet ---------------------------->
-                           [Here`s the info ]
-               LSR Packet ---------------------------->
-                 [I need full info on 172.16.2.0/24]
-               <---------------------------- LSU Packet
-                           [Here`s the info ]

-                                  Full
-               LSAck Packet ---------------------------->
-                              [Acknowledged]
-               <---------------------------- LSAck Packet
-                              [Acknowledged]
- 이 단계에서는 서로 인접 상태에 있으며 서로 라우팅 정보를 교환했기 때문에 완전 상태에 있다.

- Neighbor State Summary
- Down - INIT - 2-WAY - Exstart - Exchange - Loading - Full
- 위에는 점대점 링크에서 작동하는 방식 설명
- 이더넷과 같은 다중 액세스 세그먼트에서는 약간의 차이가 있으며 지정 라우터(DR)와 백업 지정 라우터(BDR)을 사용한다.

- debug 
- debug ip ospf adjacency
- undebug all -> 디버그 해제

- hello 패킷 인터벌 변경
- ip ospf hello-interval [number]
- 다른 타이머 설정으로 OSPF 인접성 해제

- 이를 디버깅 하는 명령어
- debug ip ospf Hello
- Mismatched hello parameters

- show ip ospf neighbor
- state에 Full이 아닌 Exchange가 있는 경우는 이웃이 서로를 발견하고 인접성을 형성했지만 실제로 경로를 교환하지 않는 상태
- 이 문제의 가장 일반적인 원인은 MTU 불일치 
- ip mtu 1460

- debug ip ospf adjacency
- Nbr [ IP ] has smalled interface MTU
- 양쪽의 인터페이스 MTU를 비교

- show ip ospf neighbor

- Multiaccess Segments
- 여러 개의 라우터가 있을 수 있는 이더넷과 같은 다중 액세스 세그먼트에서는모든 라우터가 서로 완전 OSPF 인접성을 형성하는 것을 비효율
- 일종의 여러 라우터 중 하나가 마스터로 선출되어 다른 라우터들이 마스터와 정보를 공유하여 해당 정보를 다른 라우터에 반영할 수 있도록 하는 게 더 좋을 것이다
- 정보를 마스터로만 전송한 뒤 마스터가 처리하게끔 
- 마스터가 DR, 지정 라우터로 불린다
- 이럴 경우 마스터에 문제가 생기면 다른 모든 곳에 문제가 생기므로 이를 방지하기 위해 다중화를 해줘야 한다.
- 즉 마스터인 DR 지정 라우터도 두고 백업 지정 라우터인 BDR도 두어 DR의 이상이 발생할 경우를 대비한다.

- 가장 우선 순위가 높은 라우타가 DR이 되고 두 번쨰로 우선 순위가 높은 라우터가 BDR이 된다.
- 라우터의 우선 순위 기본값은 1이고, 이 숫자가 높을 수록 더 선호되는 라우터다
- 가능한 값은 0~255로, 255가 가장 좋은 값이다
- 값이 같을 경우 더 높은 라우터 ID를 가진 라우터가 선출된다.

- DB과 BDR의 선출은 라우팅 정보가 교환되기 전인 양방향 ( 2-WAY ) 단계에서 이루어진다.
- 모든 라우터가 서로 전체 정보를 공유하는게 아니라 DR과 BDR에게만 공유하므로
- 그래서 라우터간에 라우팅 정보를 교환하기 전에 이를 설정해야 합니다.
- 다중 액세스 세그먼트에서 발생 

- DR로 지정될 라우터를 수동으로 설정 명령어 -> 인터페이스 수준에서
- interface FastEthernet 0/0
- ip ospf priority 100

- ip ospf priority 0 -> 선출되지 않게 할려면

- DR과 BDR은 네트워크 세그먼트 상의 모든 라우터와 완전 이웃 상태를 형성
- 다른 라우터들의 이웃 상태는 양방향 ( 2-WAY ) 상태로 유지되며 서로 경로를 직접 교환하지 않는다.

- 새로운 링크가 생기거나, 링크가 끊어지는 등 링크 상태에 변화가 생기고 이 링크가 멀티 액세스 세그먼트에 연결된 경우
- 멀티캐스트 주소 224.0.0.6로 지정된 모든 라우터들에게 멀티캐스트 LSU, 즉 링크 상태 업데이트 패킷을 전송한다.
- DB과 BDR만이 해당 주소로 전송된 패킷의 수신을 대기하고 있는다.

- 링크 상태의 변화를 확인하게 되면 224.0.0.6으로 업데이트를 보내고 DB과 BDR 모두 그 변화에 대해 학습
- 그러면 BDR 말고 DR만이 224.0.0.5에 있는 모든 OSPF 라우터에 그 변화를 멀티캐스트 한다.
- 그러면 그 링크에 있는 모든 OSPF 라우터들이 그 변화를 학습하게 된다.
- 즉, 어떤 변화가 생기면 DB과 BDR로 전송이 되고 DR이 링크에 있는 다른 라우터들에게 변화 업데이트를 보낸다.
- 변화가 생기면 그 링크에 있는 모든 라우터가 그 변화를 학습할 수 있다.

- show ip ospf neighbor
- state 
- FULL/DR 
- FULL/BDR

- 세그먼트 상에서 DR을 일일이 확인하지 않고 특정 라우터에서 찾을려면
- show ip ospf interface FastEthernet0/0
- Designated Router (ID) [ Router ID ]

- clear ip ospf process -> 빠른 적용 확인. 현업 사용 신중히